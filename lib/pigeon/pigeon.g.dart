// Autogenerated from Pigeon (v26.1.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

List<Object?> wrapResponse({Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}
bool _deepEquals(Object? a, Object? b) {
  if (a is List && b is List) {
    return a.length == b.length &&
        a.indexed
        .every(((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]));
  }
  if (a is Map && b is Map) {
    return a.length == b.length && a.entries.every((MapEntry<Object?, Object?> entry) =>
        (b as Map<Object?, Object?>).containsKey(entry.key) &&
        _deepEquals(entry.value, b[entry.key]));
  }
  return a == b;
}


enum PasteLabelStyle {
  automatic,
  titleOnly,
  iconOnly,
  titleAndIcon,
}

enum PasteAlignmentDirection {
  horizontal,
  vertical,
}

enum PasteAlignment {
  bottom,
  bottomLeading,
  bottomTrailing,
  center,
  centerFirstTextBaseline,
  centerLastTextBaseline,
  leading,
  leadingFirstTextBaseline,
  leadingLastTextBaseline,
  top,
  topLeading,
  topTrailing,
  trailing,
  trailingFirstTextBaseline,
  trailingLastTextBaseline,
}

enum PasteButtonBorderShape {
  automatic,
  roundedRectangle,
  capsule,
  circle,
}

enum VersionOverride {
  iOS14,
  iOS13,
}

class PasteColor {
  PasteColor({
    required this.r,
    required this.g,
    required this.b,
    required this.a,
  });

  double r;

  double g;

  double b;

  double a;

  List<Object?> _toList() {
    return <Object?>[
      r,
      g,
      b,
      a,
    ];
  }

  Object encode() {
    return _toList();  }

  static PasteColor decode(Object result) {
    result as List<Object?>;
    return PasteColor(
      r: result[0]! as double,
      g: result[1]! as double,
      b: result[2]! as double,
      a: result[3]! as double,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! PasteColor || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}

class PasteButtonParams {
  PasteButtonParams({
    this.color,
    this.labelStyle,
    this.buttonBorderShape,
    this.buttonBorderShapeRadius,
    this.width,
    this.height,
    this.alignment,
    this.versionOverride,
  });

  PasteColor? color;

  PasteLabelStyle? labelStyle;

  PasteButtonBorderShape? buttonBorderShape;

  double? buttonBorderShapeRadius;

  double? width;

  double? height;

  PasteAlignment? alignment;

  VersionOverride? versionOverride;

  List<Object?> _toList() {
    return <Object?>[
      color,
      labelStyle,
      buttonBorderShape,
      buttonBorderShapeRadius,
      width,
      height,
      alignment,
      versionOverride,
    ];
  }

  Object encode() {
    return _toList();  }

  static PasteButtonParams decode(Object result) {
    result as List<Object?>;
    return PasteButtonParams(
      color: result[0] as PasteColor?,
      labelStyle: result[1] as PasteLabelStyle?,
      buttonBorderShape: result[2] as PasteButtonBorderShape?,
      buttonBorderShapeRadius: result[3] as double?,
      width: result[4] as double?,
      height: result[5] as double?,
      alignment: result[6] as PasteAlignment?,
      versionOverride: result[7] as VersionOverride?,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! PasteButtonParams || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList())
;
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is PasteLabelStyle) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    }    else if (value is PasteAlignmentDirection) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    }    else if (value is PasteAlignment) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    }    else if (value is PasteButtonBorderShape) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    }    else if (value is VersionOverride) {
      buffer.putUint8(133);
      writeValue(buffer, value.index);
    }    else if (value is PasteColor) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    }    else if (value is PasteButtonParams) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PasteLabelStyle.values[value];
      case 130: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PasteAlignmentDirection.values[value];
      case 131: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PasteAlignment.values[value];
      case 132: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PasteButtonBorderShape.values[value];
      case 133: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : VersionOverride.values[value];
      case 134: 
        return PasteColor.decode(readValue(buffer)!);
      case 135: 
        return PasteButtonParams.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class MessageFlutterApi {
  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  void flutterMethod(int id, List<String> data);

  static void setUp(MessageFlutterApi? api, {BinaryMessenger? binaryMessenger, String messageChannelSuffix = '',}) {
    messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.swiftui_paste_button.MessageFlutterApi.flutterMethod$messageChannelSuffix', pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.swiftui_paste_button.MessageFlutterApi.flutterMethod was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final int? arg_id = (args[0] as int?);
          assert(arg_id != null,
              'Argument for dev.flutter.pigeon.swiftui_paste_button.MessageFlutterApi.flutterMethod was null, expected non-null int.');
          final List<String>? arg_data = (args[1] as List<Object?>?)?.cast<String>();
          assert(arg_data != null,
              'Argument for dev.flutter.pigeon.swiftui_paste_button.MessageFlutterApi.flutterMethod was null, expected non-null List<String>.');
          try {
            api.flutterMethod(arg_id!, arg_data!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}
